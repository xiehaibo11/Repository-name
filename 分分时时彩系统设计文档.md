# ğŸ¯ åˆ†åˆ†æ—¶æ—¶å½©ç³»ç»Ÿå®Œæ•´è®¾è®¡æ–¹æ¡ˆ

## ğŸ“‹ ç³»ç»Ÿæ¦‚è¿°

åŸºäºç©æ³•æ–‡æ¡£ï¼Œè®¾è®¡ä¸€ä¸ªå®Œæ•´çš„åˆ†åˆ†æ—¶æ—¶å½©ç³»ç»Ÿï¼ŒåŒ…å«å¼€å¥–å¼•æ“ã€æŠ•æ³¨ç³»ç»Ÿã€ç»“ç®—ç³»ç»Ÿç­‰æ ¸å¿ƒæ¨¡å—ã€‚

## ğŸ² æ ¸å¿ƒæ•°æ®ç»“æ„

### 1. å¼€å¥–ç»“æœæ•°æ®ç»“æ„

```typescript
interface DrawResult {
  // åŸºç¡€ä¿¡æ¯
  issueNo: string;           // æœŸå· (æ ¼å¼: YYYYMMDDHHMM)
  drawTime: Date;            // å¼€å¥–æ—¶é—´
  
  // å¼€å¥–å·ç  (ä¸‡åƒç™¾åä¸ª)
  numbers: {
    wan: number;             // ä¸‡ä½ (0-9)
    qian: number;            // åƒä½ (0-9)
    bai: number;             // ç™¾ä½ (0-9)
    shi: number;             // åä½ (0-9)
    ge: number;              // ä¸ªä½ (0-9)
  };
  
  // è‡ªåŠ¨è®¡ç®—çš„å±æ€§
  calculated: {
    // å’Œå€¼ç›¸å…³
    sum: number;             // å’Œå€¼ (0-45)
    sumBigSmall: 'big' | 'small';    // å’Œå€¼å¤§å° (23-45å¤§, 0-22å°)
    sumOddEven: 'odd' | 'even';      // å’Œå€¼å•åŒ
    
    // å„ä½å±æ€§
    positions: {
      wan: PositionAttributes;
      qian: PositionAttributes;
      bai: PositionAttributes;
      shi: PositionAttributes;
      ge: PositionAttributes;
    };
    
    // é¾™è™ (ç¬¬1ä½ vs ç¬¬5ä½)
    dragonTiger: 'dragon' | 'tiger' | 'tie';
    
    // å¥‡å¶ç»Ÿè®¡
    oddEvenCount: {
      oddCount: number;      // å¥‡æ•°ä¸ªæ•°
      evenCount: number;     // å¶æ•°ä¸ªæ•°
    };
    
    // è·¨åº¦
    spans: {
      front3: number;        // å‰ä¸‰è·¨åº¦ (ä¸‡åƒç™¾)
      middle3: number;       // ä¸­ä¸‰è·¨åº¦ (åƒç™¾å)
      back3: number;         // åä¸‰è·¨åº¦ (ç™¾åä¸ª)
    };
    
    // ç‰›ç‰›ç›¸å…³
    bull: BullResult;
    
    // ç‰›æ¢­å“ˆç›¸å…³
    poker: PokerResult;
  };
}

interface PositionAttributes {
  value: number;             // æ•°å­—å€¼ (0-9)
  bigSmall: 'big' | 'small'; // å¤§å° (5-9å¤§, 0-4å°)
  oddEven: 'odd' | 'even';   // å•åŒ (1,3,5,7,9å•, 0,2,4,6,8åŒ)
  primeComposite: 'prime' | 'composite'; // è´¨åˆ (1,2,3,5,7è´¨, 0,4,6,8,9åˆ)
}

interface BullResult {
  type: 'none' | 'bull1' | 'bull2' | 'bull3' | 'bull4' | 'bull5' | 
        'bull6' | 'bull7' | 'bull8' | 'bull9' | 'bullbull';
  value: number;             // ç‰›å‡  (0-10, 10ä¸ºç‰›ç‰›)
  bigSmall: 'big' | 'small'; // ç‰›å¤§å°
  oddEven: 'odd' | 'even';   // ç‰›å•åŒ
  primeComposite: 'prime' | 'composite'; // ç‰›è´¨åˆ
}

interface PokerResult {
  type: 'fiveOfKind' | 'fourOfKind' | 'fullHouse' | 'straight' | 
        'threeOfKind' | 'twoPair' | 'onePair' | 'highCard';
  description: string;       // ä¸­æ–‡æè¿°
}
```

### 2. æŠ•æ³¨æ•°æ®ç»“æ„

```typescript
interface BetOrder {
  // åŸºç¡€ä¿¡æ¯
  id: string;
  userId: string;
  issueNo: string;
  betTime: Date;
  
  // æŠ•æ³¨å†…å®¹
  bets: BetItem[];
  
  // é‡‘é¢ä¿¡æ¯
  totalAmount: number;       // æ€»æŠ•æ³¨é‡‘é¢
  totalWinAmount?: number;   // æ€»ä¸­å¥–é‡‘é¢
  
  // çŠ¶æ€
  status: 'pending' | 'win' | 'lose' | 'cancelled';
  settleTime?: Date;
}

interface BetItem {
  // ç©æ³•ç±»å‹
  gameType: GameType;
  
  // æŠ•æ³¨å†…å®¹
  betContent: string;        // æŠ•æ³¨å†…å®¹æè¿°
  betValue: any;             // å…·ä½“æŠ•æ³¨å€¼
  
  // é‡‘é¢å’Œèµ”ç‡
  amount: number;            // æŠ•æ³¨é‡‘é¢
  odds: number;              // èµ”ç‡
  winAmount?: number;        // ä¸­å¥–é‡‘é¢
  
  // ç»“æœ
  isWin?: boolean;
  result?: string;           // å¼€å¥–ç»“æœæè¿°
}

type GameType = 
  // æ•°å­—ç›˜
  | 'number_wan' | 'number_qian' | 'number_bai' | 'number_shi' | 'number_ge'
  
  // åŒé¢ç©æ³•
  | 'double_wan_big_small' | 'double_wan_odd_even' | 'double_wan_prime_composite'
  | 'double_qian_big_small' | 'double_qian_odd_even' | 'double_qian_prime_composite'
  | 'double_bai_big_small' | 'double_bai_odd_even' | 'double_bai_prime_composite'
  | 'double_shi_big_small' | 'double_shi_odd_even' | 'double_shi_prime_composite'
  | 'double_ge_big_small' | 'double_ge_odd_even' | 'double_ge_prime_composite'
  | 'double_sum_big_small' | 'double_sum_odd_even'
  
  // ç‰›ç‰›ç©æ³•
  | 'bull_basic' | 'bull_double_face' | 'bull_poker'
  
  // å®šä½ç©æ³•
  | 'position_one' | 'position_two' | 'position_three'
  
  // è·¨åº¦ç©æ³•
  | 'span_front3' | 'span_middle3' | 'span_back3'
  
  // é¾™è™ç©æ³•
  | 'dragon_tiger';
```

## ğŸ¯ æ ¸å¿ƒç®—æ³•å®ç°

### 1. å¼€å¥–å·ç ç”Ÿæˆç®—æ³•

```typescript
class DrawNumberGenerator {
  /**
   * ç”Ÿæˆ5ä½å¼€å¥–å·ç 
   * ç¡®ä¿éšæœºæ€§å’Œå…¬å¹³æ€§
   */
  generateNumbers(): number[] {
    const numbers: number[] = [];
    
    for (let i = 0; i < 5; i++) {
      // ä½¿ç”¨åŠ å¯†å®‰å…¨çš„éšæœºæ•°ç”Ÿæˆå™¨
      const randomValue = crypto.randomInt(0, 10);
      numbers.push(randomValue);
    }
    
    return numbers;
  }
  
  /**
   * éªŒè¯å·ç çš„åˆç†æ€§
   * é¿å…è¿‡äºè§„å¾‹çš„å·ç 
   */
  validateNumbers(numbers: number[]): boolean {
    // æ£€æŸ¥æ˜¯å¦å…¨éƒ¨ç›¸åŒ
    if (numbers.every(n => n === numbers[0])) {
      return Math.random() < 0.001; // 1/1000æ¦‚ç‡å…è®¸
    }
    
    // æ£€æŸ¥æ˜¯å¦ä¸ºè¿ç»­æ•°å­—
    const sorted = [...numbers].sort();
    const isSequential = sorted.every((n, i) => 
      i === 0 || n === sorted[i-1] + 1
    );
    
    if (isSequential) {
      return Math.random() < 0.01; // 1/100æ¦‚ç‡å…è®¸
    }
    
    return true;
  }
}
```

### 2. ç»“æœè®¡ç®—å¼•æ“

```typescript
class ResultCalculator {
  /**
   * è®¡ç®—å¼€å¥–ç»“æœçš„æ‰€æœ‰å±æ€§
   */
  calculateResult(numbers: number[]): DrawResult['calculated'] {
    const [wan, qian, bai, shi, ge] = numbers;
    
    return {
      // å’Œå€¼è®¡ç®—
      sum: this.calculateSum(numbers),
      sumBigSmall: this.calculateSumBigSmall(numbers),
      sumOddEven: this.calculateSumOddEven(numbers),
      
      // å„ä½å±æ€§
      positions: {
        wan: this.calculatePositionAttributes(wan),
        qian: this.calculatePositionAttributes(qian),
        bai: this.calculatePositionAttributes(bai),
        shi: this.calculatePositionAttributes(shi),
        ge: this.calculatePositionAttributes(ge),
      },
      
      // é¾™è™
      dragonTiger: this.calculateDragonTiger(wan, ge),
      
      // å¥‡å¶ç»Ÿè®¡
      oddEvenCount: this.calculateOddEvenCount(numbers),
      
      // è·¨åº¦
      spans: {
        front3: this.calculateSpan([wan, qian, bai]),
        middle3: this.calculateSpan([qian, bai, shi]),
        back3: this.calculateSpan([bai, shi, ge]),
      },
      
      // ç‰›ç‰›
      bull: this.calculateBull(numbers),
      
      // ç‰›æ¢­å“ˆ
      poker: this.calculatePoker(numbers),
    };
  }
  
  private calculateSum(numbers: number[]): number {
    return numbers.reduce((sum, num) => sum + num, 0);
  }
  
  private calculateSumBigSmall(numbers: number[]): 'big' | 'small' {
    const sum = this.calculateSum(numbers);
    return sum >= 23 ? 'big' : 'small';
  }
  
  private calculateSumOddEven(numbers: number[]): 'odd' | 'even' {
    const sum = this.calculateSum(numbers);
    return sum % 2 === 0 ? 'even' : 'odd';
  }
  
  private calculatePositionAttributes(value: number): PositionAttributes {
    return {
      value,
      bigSmall: value >= 5 ? 'big' : 'small',
      oddEven: value % 2 === 0 ? 'even' : 'odd',
      primeComposite: [1, 2, 3, 5, 7].includes(value) ? 'prime' : 'composite',
    };
  }
  
  private calculateDragonTiger(first: number, last: number): 'dragon' | 'tiger' | 'tie' {
    if (first > last) return 'dragon';
    if (first < last) return 'tiger';
    return 'tie';
  }
  
  private calculateOddEvenCount(numbers: number[]): { oddCount: number; evenCount: number } {
    const oddCount = numbers.filter(n => n % 2 === 1).length;
    return {
      oddCount,
      evenCount: 5 - oddCount,
    };
  }
  
  private calculateSpan(threeNumbers: number[]): number {
    const max = Math.max(...threeNumbers);
    const min = Math.min(...threeNumbers);
    return max - min;
  }
  
  private calculateBull(numbers: number[]): BullResult {
    // ç‰›ç‰›ç®—æ³•å®ç°
    // æ‰¾å‡ºä»»æ„ä¸‰ä¸ªæ•°å­—ç›¸åŠ ä¸º10çš„å€æ•°çš„ç»„åˆ
    // ç„¶åè®¡ç®—å‰©ä½™ä¸¤ä¸ªæ•°å­—çš„å’Œçš„ä¸ªä½æ•°
    
    for (let i = 0; i < 5; i++) {
      for (let j = i + 1; j < 5; j++) {
        for (let k = j + 1; k < 5; k++) {
          const threeSum = numbers[i] + numbers[j] + numbers[k];
          if (threeSum % 10 === 0) {
            // æ‰¾åˆ°äº†ä¸‰ä¸ªæ•°å­—å’Œä¸º10çš„å€æ•°
            const remaining = numbers.filter((_, idx) => ![i, j, k].includes(idx));
            const remainingSum = remaining[0] + remaining[1];
            const bullValue = remainingSum % 10;
            
            return {
              type: bullValue === 0 ? 'bullbull' : `bull${bullValue}` as any,
              value: bullValue === 0 ? 10 : bullValue,
              bigSmall: bullValue >= 6 || bullValue === 0 ? 'big' : 'small',
              oddEven: bullValue % 2 === 0 ? 'even' : 'odd',
              primeComposite: [1, 2, 3, 5, 7].includes(bullValue) ? 'prime' : 'composite',
            };
          }
        }
      }
    }
    
    return {
      type: 'none',
      value: 0,
      bigSmall: 'small',
      oddEven: 'even',
      primeComposite: 'composite',
    };
  }
  
  private calculatePoker(numbers: number[]): PokerResult {
    const counts = new Map<number, number>();
    numbers.forEach(n => {
      counts.set(n, (counts.get(n) || 0) + 1);
    });
    
    const countValues = Array.from(counts.values()).sort((a, b) => b - a);
    
    // äº”æ¡
    if (countValues[0] === 5) {
      return { type: 'fiveOfKind', description: 'äº”æ¡' };
    }
    
    // ç‚¸å¼¹
    if (countValues[0] === 4) {
      return { type: 'fourOfKind', description: 'ç‚¸å¼¹' };
    }
    
    // è‘«èŠ¦
    if (countValues[0] === 3 && countValues[1] === 2) {
      return { type: 'fullHouse', description: 'è‘«èŠ¦' };
    }
    
    // é¡ºå­æ£€æŸ¥
    if (this.isStraight(numbers)) {
      return { type: 'straight', description: 'é¡ºå­' };
    }
    
    // ä¸‰æ¡
    if (countValues[0] === 3) {
      return { type: 'threeOfKind', description: 'ä¸‰æ¡' };
    }
    
    // ä¸¤å¯¹
    if (countValues[0] === 2 && countValues[1] === 2) {
      return { type: 'twoPair', description: 'ä¸¤å¯¹' };
    }
    
    // å•å¯¹
    if (countValues[0] === 2) {
      return { type: 'onePair', description: 'å•å¯¹' };
    }
    
    // æ•£å·
    return { type: 'highCard', description: 'æ•£å·' };
  }
  
  private isStraight(numbers: number[]): boolean {
    const sorted = [...numbers].sort((a, b) => a - b);
    
    // æ£€æŸ¥æ™®é€šé¡ºå­
    for (let i = 1; i < sorted.length; i++) {
      if (sorted[i] !== sorted[i-1] + 1) {
        break;
      }
      if (i === sorted.length - 1) {
        return true;
      }
    }
    
    // æ£€æŸ¥åŒ…å«0çš„ç‰¹æ®Šé¡ºå­ (å¦‚ 9,0,1,2,3)
    if (sorted.includes(0) && sorted.includes(9)) {
      const withoutZero = sorted.filter(n => n !== 0);
      const withTen = [...withoutZero, 10].sort((a, b) => a - b);
      
      for (let i = 1; i < withTen.length; i++) {
        if (withTen[i] !== withTen[i-1] + 1) {
          return false;
        }
      }
      return true;
    }
    
    return false;
  }
}
```

## ğŸ® æŠ•æ³¨ç³»ç»Ÿè®¾è®¡

### 1. èµ”ç‡é…ç½®ç³»ç»Ÿ

```typescript
class OddsManager {
  private static readonly ODDS_CONFIG = {
    // æ•°å­—ç›˜èµ”ç‡
    number: 9.8,
    
    // åŒé¢ç©æ³•èµ”ç‡
    doubleFace: 1.98,
    
    // ç‰›ç‰›èµ”ç‡
    bull: {
      none: 2.66,
      bull1: 14.88, bull2: 14.68, bull3: 14.88, bull4: 14.68, bull5: 14.88,
      bull6: 14.68, bull7: 14.88, bull8: 14.68, bull9: 14.88, bullbull: 14.68,
      // ç‰›åŒé¢
      bullBig: 2.68, bullSmall: 2.88,
      bullOdd: 2.98, bullEven: 2.58,
      bullPrime: 2.96, bullComposite: 2.66,
    },
    
    // ç‰›æ¢­å“ˆèµ”ç‡
    poker: {
      fiveOfKind: 9000, fourOfKind: 200, fullHouse: 100, straight: 80,
      threeOfKind: 12.88, twoPair: 8.88, onePair: 1.88, highCard: 2.98,
    },
    
    // å®šä½ç©æ³•èµ”ç‡
    position: {
      one: 9.8,
      two: 83,
      three: 690,
    },
    
    // è·¨åº¦èµ”ç‡
    span: {
      0: 71, 1: 14.8, 2: 8.1, 3: 6.2, 4: 5.4,
      5: 5.2, 6: 5.4, 7: 6.2, 8: 8.1, 9: 14.4,
    },
    
    // é¾™è™èµ”ç‡
    dragonTiger: {
      dragon: 1.98,
      tiger: 1.98,
      tie: 9,
    },
  };
  
  getOdds(gameType: GameType, betValue?: any): number {
    // æ ¹æ®æ¸¸æˆç±»å‹å’ŒæŠ•æ³¨å€¼è¿”å›å¯¹åº”èµ”ç‡
    // å®ç°å…·ä½“çš„èµ”ç‡æŸ¥æ‰¾é€»è¾‘
    return 1.98; // ç¤ºä¾‹è¿”å›å€¼
  }
}
```

## ğŸ”„ ç³»ç»Ÿæµç¨‹è®¾è®¡

### 1. å¼€å¥–æµç¨‹

```typescript
class DrawEngine {
  async executeDraw(issueNo: string): Promise<DrawResult> {
    try {
      // 1. ç”Ÿæˆå¼€å¥–å·ç 
      const generator = new DrawNumberGenerator();
      let numbers: number[];
      
      do {
        numbers = generator.generateNumbers();
      } while (!generator.validateNumbers(numbers));
      
      // 2. è®¡ç®—æ‰€æœ‰ç»“æœå±æ€§
      const calculator = new ResultCalculator();
      const calculated = calculator.calculateResult(numbers);
      
      // 3. æ„å»ºå®Œæ•´ç»“æœ
      const result: DrawResult = {
        issueNo,
        drawTime: new Date(),
        numbers: {
          wan: numbers[0],
          qian: numbers[1],
          bai: numbers[2],
          shi: numbers[3],
          ge: numbers[4],
        },
        calculated,
      };
      
      // 4. ä¿å­˜å¼€å¥–ç»“æœ
      await this.saveDrawResult(result);
      
      // 5. è§¦å‘ç»“ç®—æµç¨‹
      await this.triggerSettlement(result);
      
      return result;
    } catch (error) {
      console.error('å¼€å¥–æ‰§è¡Œå¤±è´¥:', error);
      throw error;
    }
  }
  
  private async saveDrawResult(result: DrawResult): Promise<void> {
    // ä¿å­˜åˆ°æ•°æ®åº“
  }
  
  private async triggerSettlement(result: DrawResult): Promise<void> {
    // è§¦å‘æŠ•æ³¨ç»“ç®—
    const settlementEngine = new SettlementEngine();
    await settlementEngine.settleIssue(result);
  }
}
```

### 2. ç»“ç®—æµç¨‹

```typescript
class SettlementEngine {
  async settleIssue(drawResult: DrawResult): Promise<void> {
    try {
      // 1. è·å–è¯¥æœŸæ‰€æœ‰æŠ•æ³¨
      const bets = await this.getBetsByIssue(drawResult.issueNo);
      
      // 2. é€ä¸ªåˆ¤æ–­ä¸­å¥–æƒ…å†µ
      for (const bet of bets) {
        await this.settleBet(bet, drawResult);
      }
      
      // 3. æ›´æ–°ç”¨æˆ·ä½™é¢
      await this.updateUserBalances(bets);
      
      // 4. è®°å½•ç»“ç®—æ—¥å¿—
      await this.logSettlement(drawResult.issueNo, bets);
      
    } catch (error) {
      console.error('ç»“ç®—å¤±è´¥:', error);
      throw error;
    }
  }
  
  private async settleBet(bet: BetOrder, drawResult: DrawResult): Promise<void> {
    const winChecker = new WinChecker();
    
    for (const betItem of bet.bets) {
      const isWin = winChecker.checkWin(betItem, drawResult);
      
      if (isWin) {
        betItem.isWin = true;
        betItem.winAmount = betItem.amount * betItem.odds;
      } else {
        betItem.isWin = false;
        betItem.winAmount = 0;
      }
    }
    
    // è®¡ç®—æ€»ä¸­å¥–é‡‘é¢
    bet.totalWinAmount = bet.bets.reduce((sum, item) => sum + (item.winAmount || 0), 0);
    bet.status = bet.totalWinAmount > 0 ? 'win' : 'lose';
    bet.settleTime = new Date();
    
    // æ›´æ–°æ•°æ®åº“
    await this.updateBetResult(bet);
  }
}
```

## ğŸ¯ ä¸­å¥–åˆ¤æ–­ç³»ç»Ÿ

### 1. ä¸­å¥–åˆ¤æ–­å¼•æ“

```typescript
class WinChecker {
  checkWin(betItem: BetItem, drawResult: DrawResult): boolean {
    const { gameType, betValue } = betItem;
    const { numbers, calculated } = drawResult;

    switch (gameType) {
      // æ•°å­—ç›˜ç©æ³•
      case 'number_wan': return numbers.wan === betValue;
      case 'number_qian': return numbers.qian === betValue;
      case 'number_bai': return numbers.bai === betValue;
      case 'number_shi': return numbers.shi === betValue;
      case 'number_ge': return numbers.ge === betValue;

      // åŒé¢ç©æ³• - å„ä½å¤§å°
      case 'double_wan_big_small':
        return calculated.positions.wan.bigSmall === betValue;
      case 'double_qian_big_small':
        return calculated.positions.qian.bigSmall === betValue;
      case 'double_bai_big_small':
        return calculated.positions.bai.bigSmall === betValue;
      case 'double_shi_big_small':
        return calculated.positions.shi.bigSmall === betValue;
      case 'double_ge_big_small':
        return calculated.positions.ge.bigSmall === betValue;

      // åŒé¢ç©æ³• - å„ä½å•åŒ
      case 'double_wan_odd_even':
        return calculated.positions.wan.oddEven === betValue;
      case 'double_qian_odd_even':
        return calculated.positions.qian.oddEven === betValue;
      case 'double_bai_odd_even':
        return calculated.positions.bai.oddEven === betValue;
      case 'double_shi_odd_even':
        return calculated.positions.shi.oddEven === betValue;
      case 'double_ge_odd_even':
        return calculated.positions.ge.oddEven === betValue;

      // åŒé¢ç©æ³• - å„ä½è´¨åˆ
      case 'double_wan_prime_composite':
        return calculated.positions.wan.primeComposite === betValue;
      case 'double_qian_prime_composite':
        return calculated.positions.qian.primeComposite === betValue;
      case 'double_bai_prime_composite':
        return calculated.positions.bai.primeComposite === betValue;
      case 'double_shi_prime_composite':
        return calculated.positions.shi.primeComposite === betValue;
      case 'double_ge_prime_composite':
        return calculated.positions.ge.primeComposite === betValue;

      // æ€»å’ŒåŒé¢
      case 'double_sum_big_small':
        return calculated.sumBigSmall === betValue;
      case 'double_sum_odd_even':
        return calculated.sumOddEven === betValue;

      // ç‰›ç‰›ç©æ³•
      case 'bull_basic':
        return calculated.bull.type === betValue;
      case 'bull_double_face':
        return this.checkBullDoubleFace(calculated.bull, betValue);

      // ç‰›æ¢­å“ˆ
      case 'bull_poker':
        return calculated.poker.type === betValue;

      // å®šä½ç©æ³•
      case 'position_one':
        return this.checkPositionOne(numbers, betValue);
      case 'position_two':
        return this.checkPositionTwo(numbers, betValue);
      case 'position_three':
        return this.checkPositionThree(numbers, betValue);

      // è·¨åº¦ç©æ³•
      case 'span_front3':
        return calculated.spans.front3 === betValue;
      case 'span_middle3':
        return calculated.spans.middle3 === betValue;
      case 'span_back3':
        return calculated.spans.back3 === betValue;

      // é¾™è™ç©æ³•
      case 'dragon_tiger':
        return this.checkDragonTiger(calculated.dragonTiger, betValue);

      default:
        return false;
    }
  }

  private checkBullDoubleFace(bull: BullResult, betValue: any): boolean {
    const { type, bigSmall, oddEven, primeComposite } = betValue;

    switch (type) {
      case 'big_small': return bull.bigSmall === betValue.value;
      case 'odd_even': return bull.oddEven === betValue.value;
      case 'prime_composite': return bull.primeComposite === betValue.value;
      default: return false;
    }
  }

  private checkPositionOne(numbers: any, betValue: any): boolean {
    const { position, value } = betValue;
    return numbers[position] === value;
  }

  private checkPositionTwo(numbers: any, betValue: any): boolean {
    const { positions, values } = betValue;
    return positions.every((pos: string, idx: number) =>
      numbers[pos] === values[idx]
    );
  }

  private checkPositionThree(numbers: any, betValue: any): boolean {
    const { positions, values } = betValue;
    return positions.every((pos: string, idx: number) =>
      numbers[pos] === values[idx]
    );
  }

  private checkDragonTiger(result: string, betValue: any): boolean {
    const { positions, bet } = betValue;
    // positions: ['wan', 'ge'], bet: 'dragon'
    return result === bet;
  }
}
```

## ğŸ• æœŸå·ç”Ÿæˆç³»ç»Ÿ

### 1. æœŸå·ç”Ÿæˆå™¨

```typescript
class IssueGenerator {
  /**
   * ç”Ÿæˆå½“å‰æœŸå·
   * æ ¼å¼: YYYYMMDDHHMM (å¹´æœˆæ—¥æ—¶åˆ†)
   */
  generateCurrentIssue(): string {
    const now = new Date();
    const year = now.getFullYear().toString();
    const month = (now.getMonth() + 1).toString().padStart(2, '0');
    const day = now.getDate().toString().padStart(2, '0');
    const hour = now.getHours().toString().padStart(2, '0');
    const minute = now.getMinutes().toString().padStart(2, '0');

    return `${year}${month}${day}${hour}${minute}`;
  }

  /**
   * ç”Ÿæˆä¸‹ä¸€æœŸå·
   */
  generateNextIssue(currentIssue: string): string {
    const currentTime = this.parseIssueToDate(currentIssue);
    const nextTime = new Date(currentTime.getTime() + 60 * 1000); // åŠ 1åˆ†é’Ÿ

    return this.formatDateToIssue(nextTime);
  }

  /**
   * è§£ææœŸå·ä¸ºæ—¥æœŸ
   */
  parseIssueToDate(issue: string): Date {
    const year = parseInt(issue.substring(0, 4));
    const month = parseInt(issue.substring(4, 6)) - 1;
    const day = parseInt(issue.substring(6, 8));
    const hour = parseInt(issue.substring(8, 10));
    const minute = parseInt(issue.substring(10, 12));

    return new Date(year, month, day, hour, minute);
  }

  /**
   * æ ¼å¼åŒ–æ—¥æœŸä¸ºæœŸå·
   */
  formatDateToIssue(date: Date): string {
    const year = date.getFullYear().toString();
    const month = (date.getMonth() + 1).toString().padStart(2, '0');
    const day = date.getDate().toString().padStart(2, '0');
    const hour = date.getHours().toString().padStart(2, '0');
    const minute = date.getMinutes().toString().padStart(2, '0');

    return `${year}${month}${day}${hour}${minute}`;
  }

  /**
   * è·å–ä»Šæ—¥æ‰€æœ‰æœŸå·
   */
  getTodayIssues(): string[] {
    const today = new Date();
    const startOfDay = new Date(today.getFullYear(), today.getMonth(), today.getDate());
    const issues: string[] = [];

    for (let i = 0; i < 1440; i++) { // 1440åˆ†é’Ÿ = 24å°æ—¶
      const issueTime = new Date(startOfDay.getTime() + i * 60 * 1000);
      issues.push(this.formatDateToIssue(issueTime));
    }

    return issues;
  }
}
```

## â° å€’è®¡æ—¶ç³»ç»Ÿ

### 1. å€’è®¡æ—¶ç®¡ç†å™¨

```typescript
class CountdownManager {
  private currentIssue: string = '';
  private nextDrawTime: Date = new Date();
  private countdownInterval: NodeJS.Timeout | null = null;

  /**
   * å¯åŠ¨å€’è®¡æ—¶ç³»ç»Ÿ
   */
  start(): void {
    this.updateCurrentIssue();
    this.startCountdown();

    // æ¯åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡æœŸå·æ›´æ–°
    setInterval(() => {
      this.updateCurrentIssue();
    }, 60000);
  }

  /**
   * æ›´æ–°å½“å‰æœŸå·å’Œå¼€å¥–æ—¶é—´
   */
  private updateCurrentIssue(): void {
    const generator = new IssueGenerator();
    const now = new Date();

    // è®¡ç®—ä¸‹ä¸€ä¸ªæ•´åˆ†é’Ÿæ—¶é—´
    const nextMinute = new Date(now);
    nextMinute.setSeconds(0, 0);
    nextMinute.setMinutes(nextMinute.getMinutes() + 1);

    this.currentIssue = generator.formatDateToIssue(nextMinute);
    this.nextDrawTime = nextMinute;

    console.log(`å½“å‰æœŸå·: ${this.currentIssue}, å¼€å¥–æ—¶é—´: ${this.nextDrawTime.toLocaleString()}`);
  }

  /**
   * å¯åŠ¨å€’è®¡æ—¶
   */
  private startCountdown(): void {
    if (this.countdownInterval) {
      clearInterval(this.countdownInterval);
    }

    this.countdownInterval = setInterval(() => {
      const now = new Date();
      const remainingMs = this.nextDrawTime.getTime() - now.getTime();

      if (remainingMs <= 0) {
        // æ—¶é—´åˆ°ï¼Œæ‰§è¡Œå¼€å¥–
        this.executeDraw();
        this.updateCurrentIssue();
      } else {
        // æ›´æ–°å€’è®¡æ—¶
        const remainingSeconds = Math.ceil(remainingMs / 1000);
        this.broadcastCountdown(remainingSeconds);
      }
    }, 1000);
  }

  /**
   * æ‰§è¡Œå¼€å¥–
   */
  private async executeDraw(): Promise<void> {
    try {
      console.log(`å¼€å§‹å¼€å¥– - æœŸå·: ${this.currentIssue}`);

      const drawEngine = new DrawEngine();
      const result = await drawEngine.executeDraw(this.currentIssue);

      console.log(`å¼€å¥–å®Œæˆ - æœŸå·: ${this.currentIssue}, å·ç : ${Object.values(result.numbers).join(',')}`);

      // å¹¿æ’­å¼€å¥–ç»“æœ
      this.broadcastDrawResult(result);

    } catch (error) {
      console.error(`å¼€å¥–å¤±è´¥ - æœŸå·: ${this.currentIssue}`, error);
    }
  }

  /**
   * å¹¿æ’­å€’è®¡æ—¶
   */
  private broadcastCountdown(seconds: number): void {
    // é€šè¿‡WebSocketæˆ–å…¶ä»–æ–¹å¼å¹¿æ’­å€’è®¡æ—¶
    const countdownData = {
      type: 'countdown',
      issueNo: this.currentIssue,
      remainingSeconds: seconds,
      drawTime: this.nextDrawTime.toISOString(),
    };

    // WebSocketManager.broadcast(countdownData);
    console.log(`å€’è®¡æ—¶: ${seconds}ç§’`);
  }

  /**
   * å¹¿æ’­å¼€å¥–ç»“æœ
   */
  private broadcastDrawResult(result: DrawResult): void {
    const resultData = {
      type: 'draw_result',
      result,
    };

    // WebSocketManager.broadcast(resultData);
  }

  /**
   * è·å–å½“å‰å€’è®¡æ—¶ä¿¡æ¯
   */
  getCurrentCountdown(): any {
    const now = new Date();
    const remainingMs = this.nextDrawTime.getTime() - now.getTime();
    const remainingSeconds = Math.max(0, Math.ceil(remainingMs / 1000));

    return {
      issueNo: this.currentIssue,
      drawTime: this.nextDrawTime.toISOString(),
      remainingSeconds,
      isActive: remainingSeconds > 0,
    };
  }
}
```

## ğŸ® å‰ç«¯ç•Œé¢è®¾è®¡

### 1. å€’è®¡æ—¶ç»„ä»¶

```vue
<template>
  <div class="countdown-container">
    <div class="issue-info">
      <h3>å½“å‰æœŸå·: {{ currentIssue }}</h3>
      <p>å¼€å¥–æ—¶é—´: {{ drawTime }}</p>
    </div>

    <div class="countdown-display">
      <div class="countdown-circle">
        <div class="countdown-text">
          <span class="seconds">{{ remainingSeconds }}</span>
          <span class="label">ç§’</span>
        </div>
      </div>
    </div>

    <div class="status-info">
      <span :class="statusClass">{{ statusText }}</span>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, onMounted, onUnmounted } from 'vue';

const currentIssue = ref('');
const drawTime = ref('');
const remainingSeconds = ref(60);
const isActive = ref(true);

let countdownInterval: NodeJS.Timeout | null = null;

const statusClass = computed(() => ({
  'status-betting': isActive.value && remainingSeconds.value > 10,
  'status-closing': isActive.value && remainingSeconds.value <= 10,
  'status-drawing': !isActive.value,
}));

const statusText = computed(() => {
  if (!isActive.value) return 'å¼€å¥–ä¸­...';
  if (remainingSeconds.value <= 10) return 'å³å°†æˆªæ­¢';
  return 'æŠ•æ³¨ä¸­';
});

const fetchCountdown = async () => {
  try {
    const response = await fetch('/api/ssc/countdown');
    const data = await response.json();

    currentIssue.value = data.issueNo;
    drawTime.value = new Date(data.drawTime).toLocaleString();
    remainingSeconds.value = data.remainingSeconds;
    isActive.value = data.isActive;
  } catch (error) {
    console.error('è·å–å€’è®¡æ—¶å¤±è´¥:', error);
  }
};

const startCountdown = () => {
  countdownInterval = setInterval(() => {
    if (remainingSeconds.value > 0) {
      remainingSeconds.value--;
    } else {
      // å€’è®¡æ—¶ç»“æŸï¼Œé‡æ–°è·å–æ•°æ®
      fetchCountdown();
    }
  }, 1000);
};

onMounted(() => {
  fetchCountdown();
  startCountdown();
});

onUnmounted(() => {
  if (countdownInterval) {
    clearInterval(countdownInterval);
  }
});
</script>

<style scoped>
.countdown-container {
  text-align: center;
  padding: 20px;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  border-radius: 15px;
  color: white;
  margin-bottom: 20px;
}

.countdown-circle {
  width: 120px;
  height: 120px;
  border: 4px solid rgba(255, 255, 255, 0.3);
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  margin: 20px auto;
  position: relative;
}

.countdown-text {
  text-align: center;
}

.seconds {
  font-size: 36px;
  font-weight: bold;
  display: block;
}

.label {
  font-size: 14px;
  opacity: 0.8;
}

.status-betting {
  color: #4CAF50;
  font-weight: bold;
}

.status-closing {
  color: #FF9800;
  font-weight: bold;
  animation: blink 1s infinite;
}

.status-drawing {
  color: #F44336;
  font-weight: bold;
}

@keyframes blink {
  0%, 50% { opacity: 1; }
  51%, 100% { opacity: 0.5; }
}
</style>
```

è¿™ä¸ªå®Œæ•´çš„è®¾è®¡æ–¹æ¡ˆæ¶µç›–äº†æ‚¨æ–‡æ¡£ä¸­çš„æ‰€æœ‰ç©æ³•ç»†èŠ‚ï¼ŒåŒ…æ‹¬ï¼š

1. **å®Œæ•´çš„æ•°æ®ç»“æ„** - æ”¯æŒæ‰€æœ‰ç©æ³•ç±»å‹
2. **ç²¾ç¡®çš„ç®—æ³•å®ç°** - å’Œå€¼ã€å¤§å°ã€å•åŒã€é¾™è™ã€å¥‡å¶ç­‰æ‰€æœ‰è®¡ç®—
3. **ä¸“ä¸šçš„å¼€å¥–å¼•æ“** - 1åˆ†é’Ÿä¸€æœŸçš„ç²¾ç¡®æ§åˆ¶
4. **å®Œå–„çš„æŠ•æ³¨ç³»ç»Ÿ** - æ”¯æŒæ‰€æœ‰æŠ•æ³¨ç±»å‹å’Œèµ”ç‡
5. **å®æ—¶å€’è®¡æ—¶** - ç²¾ç¡®åˆ°ç§’çš„å€’è®¡æ—¶æ˜¾ç¤º
6. **è‡ªåŠ¨ç»“ç®—** - å®Œæ•´çš„ä¸­å¥–åˆ¤æ–­å’Œç»“ç®—æµç¨‹

## ğŸ—„ï¸ æ•°æ®åº“è®¾è®¡

### 1. æ ¸å¿ƒè¡¨ç»“æ„

```sql
-- å¼€å¥–ç»“æœè¡¨
CREATE TABLE ssc_draw_results (
    id BIGSERIAL PRIMARY KEY,
    issue_no VARCHAR(12) UNIQUE NOT NULL,
    draw_time TIMESTAMP NOT NULL,

    -- å¼€å¥–å·ç 
    wan_number SMALLINT NOT NULL CHECK (wan_number >= 0 AND wan_number <= 9),
    qian_number SMALLINT NOT NULL CHECK (qian_number >= 0 AND qian_number <= 9),
    bai_number SMALLINT NOT NULL CHECK (bai_number >= 0 AND bai_number <= 9),
    shi_number SMALLINT NOT NULL CHECK (shi_number >= 0 AND shi_number <= 9),
    ge_number SMALLINT NOT NULL CHECK (ge_number >= 0 AND ge_number <= 9),

    -- å’Œå€¼ç›¸å…³
    sum_value SMALLINT NOT NULL,
    sum_big_small VARCHAR(5) NOT NULL CHECK (sum_big_small IN ('big', 'small')),
    sum_odd_even VARCHAR(4) NOT NULL CHECK (sum_odd_even IN ('odd', 'even')),

    -- å„ä½å±æ€§ (JSONæ ¼å¼å­˜å‚¨)
    positions_attributes JSONB NOT NULL,

    -- é¾™è™
    dragon_tiger VARCHAR(6) NOT NULL CHECK (dragon_tiger IN ('dragon', 'tiger', 'tie')),

    -- å¥‡å¶ç»Ÿè®¡
    odd_count SMALLINT NOT NULL,
    even_count SMALLINT NOT NULL,

    -- è·¨åº¦
    front3_span SMALLINT NOT NULL,
    middle3_span SMALLINT NOT NULL,
    back3_span SMALLINT NOT NULL,

    -- ç‰›ç‰›ç»“æœ (JSONæ ¼å¼)
    bull_result JSONB NOT NULL,

    -- ç‰›æ¢­å“ˆç»“æœ (JSONæ ¼å¼)
    poker_result JSONB NOT NULL,

    -- çŠ¶æ€å’Œæ—¶é—´
    status VARCHAR(10) DEFAULT 'completed',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- æŠ•æ³¨è®¢å•è¡¨
CREATE TABLE ssc_bet_orders (
    id BIGSERIAL PRIMARY KEY,
    order_no VARCHAR(32) UNIQUE NOT NULL,
    user_id BIGINT NOT NULL,
    issue_no VARCHAR(12) NOT NULL,

    -- æŠ•æ³¨ä¿¡æ¯
    total_amount DECIMAL(10,2) NOT NULL,
    total_win_amount DECIMAL(10,2) DEFAULT 0,
    bet_count INTEGER NOT NULL,

    -- çŠ¶æ€
    status VARCHAR(10) NOT NULL DEFAULT 'pending'
        CHECK (status IN ('pending', 'win', 'lose', 'cancelled')),

    -- æ—¶é—´
    bet_time TIMESTAMP NOT NULL,
    settle_time TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    -- ç´¢å¼•
    INDEX idx_user_issue (user_id, issue_no),
    INDEX idx_issue_status (issue_no, status),
    INDEX idx_bet_time (bet_time)
);

-- æŠ•æ³¨æ˜ç»†è¡¨
CREATE TABLE ssc_bet_items (
    id BIGSERIAL PRIMARY KEY,
    order_id BIGINT NOT NULL REFERENCES ssc_bet_orders(id),

    -- æŠ•æ³¨å†…å®¹
    game_type VARCHAR(50) NOT NULL,
    bet_content TEXT NOT NULL,
    bet_value JSONB NOT NULL,

    -- é‡‘é¢å’Œèµ”ç‡
    amount DECIMAL(10,2) NOT NULL,
    odds DECIMAL(8,2) NOT NULL,
    win_amount DECIMAL(10,2) DEFAULT 0,

    -- ç»“æœ
    is_win BOOLEAN,
    result_description TEXT,

    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- èµ”ç‡é…ç½®è¡¨
CREATE TABLE ssc_odds_config (
    id SERIAL PRIMARY KEY,
    game_type VARCHAR(50) NOT NULL,
    bet_type VARCHAR(50) NOT NULL,
    odds DECIMAL(8,2) NOT NULL,
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    UNIQUE(game_type, bet_type)
);

-- ç³»ç»Ÿé…ç½®è¡¨
CREATE TABLE ssc_system_config (
    id SERIAL PRIMARY KEY,
    config_key VARCHAR(50) UNIQUE NOT NULL,
    config_value TEXT NOT NULL,
    description TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### 2. ç´¢å¼•ä¼˜åŒ–

```sql
-- å¼€å¥–ç»“æœè¡¨ç´¢å¼•
CREATE INDEX idx_draw_results_issue ON ssc_draw_results(issue_no);
CREATE INDEX idx_draw_results_time ON ssc_draw_results(draw_time);
CREATE INDEX idx_draw_results_status ON ssc_draw_results(status);

-- æŠ•æ³¨è®¢å•è¡¨ç´¢å¼•
CREATE INDEX idx_bet_orders_user ON ssc_bet_orders(user_id);
CREATE INDEX idx_bet_orders_issue ON ssc_bet_orders(issue_no);
CREATE INDEX idx_bet_orders_status ON ssc_bet_orders(status);
CREATE INDEX idx_bet_orders_bet_time ON ssc_bet_orders(bet_time);

-- æŠ•æ³¨æ˜ç»†è¡¨ç´¢å¼•
CREATE INDEX idx_bet_items_order ON ssc_bet_items(order_id);
CREATE INDEX idx_bet_items_game_type ON ssc_bet_items(game_type);
```

## ğŸ”Œ APIæ¥å£è®¾è®¡

### 1. å¼€å¥–ç›¸å…³æ¥å£

```typescript
// è·å–å½“å‰å€’è®¡æ—¶
GET /api/ssc/countdown
Response: {
  status: 'success',
  data: {
    issueNo: '202507281015',
    drawTime: '2025-07-28T10:15:00.000Z',
    remainingSeconds: 45,
    isActive: true
  }
}

// è·å–æœ€æ–°å¼€å¥–ç»“æœ
GET /api/ssc/latest-result
Response: {
  status: 'success',
  data: {
    issueNo: '202507281014',
    drawTime: '2025-07-28T10:14:00.000Z',
    numbers: {
      wan: 3, qian: 8, bai: 2, shi: 1, ge: 7
    },
    calculated: {
      sum: 21,
      sumBigSmall: 'small',
      sumOddEven: 'odd',
      dragonTiger: 'tiger',
      // ... å…¶ä»–è®¡ç®—ç»“æœ
    }
  }
}

// è·å–å†å²å¼€å¥–è®°å½•
GET /api/ssc/history?page=1&limit=20&date=2025-07-28
Response: {
  status: 'success',
  data: {
    total: 1440,
    page: 1,
    limit: 20,
    results: [
      {
        issueNo: '202507281014',
        drawTime: '2025-07-28T10:14:00.000Z',
        numbers: { wan: 3, qian: 8, bai: 2, shi: 1, ge: 7 },
        calculated: { /* è®¡ç®—ç»“æœ */ }
      }
      // ... æ›´å¤šè®°å½•
    ]
  }
}
```

### 2. æŠ•æ³¨ç›¸å…³æ¥å£

```typescript
// æäº¤æŠ•æ³¨
POST /api/ssc/bet
Request: {
  issueNo: '202507281015',
  bets: [
    {
      gameType: 'number_wan',
      betValue: 3,
      amount: 100
    },
    {
      gameType: 'double_sum_big_small',
      betValue: 'big',
      amount: 50
    }
  ]
}
Response: {
  status: 'success',
  data: {
    orderNo: 'SSC202507281015001',
    totalAmount: 150,
    betCount: 2,
    estimatedWin: 1130 // é¢„è®¡æœ€å¤§ä¸­å¥–é‡‘é¢
  }
}

// è·å–æŠ•æ³¨è®°å½•
GET /api/ssc/my-bets?page=1&limit=20&status=all
Response: {
  status: 'success',
  data: {
    total: 50,
    page: 1,
    limit: 20,
    orders: [
      {
        orderNo: 'SSC202507281015001',
        issueNo: '202507281015',
        totalAmount: 150,
        totalWinAmount: 0,
        status: 'lose',
        betTime: '2025-07-28T10:14:30.000Z',
        settleTime: '2025-07-28T10:15:00.000Z',
        bets: [
          {
            gameType: 'number_wan',
            betContent: 'ä¸‡ä½ 3',
            amount: 100,
            odds: 9.8,
            isWin: false
          }
        ]
      }
    ]
  }
}
```

### 3. èµ”ç‡ç›¸å…³æ¥å£

```typescript
// è·å–æ‰€æœ‰èµ”ç‡
GET /api/ssc/odds
Response: {
  status: 'success',
  data: {
    number: 9.8,
    doubleFace: 1.98,
    bull: {
      none: 2.66,
      bull1: 14.88,
      // ... å…¶ä»–ç‰›ç‰›èµ”ç‡
    },
    poker: {
      fiveOfKind: 9000,
      fourOfKind: 200,
      // ... å…¶ä»–æ¢­å“ˆèµ”ç‡
    },
    position: {
      one: 9.8,
      two: 83,
      three: 690
    },
    span: {
      0: 71, 1: 14.8, 2: 8.1,
      // ... å…¶ä»–è·¨åº¦èµ”ç‡
    },
    dragonTiger: {
      dragon: 1.98,
      tiger: 1.98,
      tie: 9
    }
  }
}

// è®¡ç®—æŠ•æ³¨é¢„æœŸæ”¶ç›Š
POST /api/ssc/calculate-win
Request: {
  bets: [
    {
      gameType: 'number_wan',
      betValue: 3,
      amount: 100
    }
  ]
}
Response: {
  status: 'success',
  data: {
    totalAmount: 100,
    maxWinAmount: 980,
    items: [
      {
        gameType: 'number_wan',
        amount: 100,
        odds: 9.8,
        maxWin: 980
      }
    ]
  }
}
```

## ğŸ¯ ç³»ç»Ÿéƒ¨ç½²æ¶æ„

### 1. æœåŠ¡å™¨æ¶æ„

```yaml
# docker-compose.yml
version: '3.8'
services:
  # å‰ç«¯æœåŠ¡
  frontend:
    build: ./vue-pure-admin
    ports:
      - "8848:80"
    depends_on:
      - backend
    environment:
      - VITE_API_BASE_URL=http://backend:3001

  # åç«¯APIæœåŠ¡
  backend:
    build: ./admin-api
    ports:
      - "3001:3001"
    depends_on:
      - postgres
      - redis
    environment:
      - DB_HOST=postgres
      - DB_PORT=5432
      - DB_NAME=ssc_system
      - DB_USER=postgres
      - DB_PASSWORD=password
      - REDIS_HOST=redis
      - REDIS_PORT=6379

  # PostgreSQLæ•°æ®åº“
  postgres:
    image: postgres:15
    ports:
      - "5432:5432"
    environment:
      - POSTGRES_DB=ssc_system
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=password
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./sql/init.sql:/docker-entrypoint-initdb.d/init.sql

  # Redisç¼“å­˜
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

  # Nginxè´Ÿè½½å‡è¡¡
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf
      - ./ssl:/etc/nginx/ssl
    depends_on:
      - frontend
      - backend

volumes:
  postgres_data:
  redis_data:
```

### 2. ç›‘æ§å’Œæ—¥å¿—

```typescript
// ç³»ç»Ÿç›‘æ§é…ç½®
class SystemMonitor {
  // æ€§èƒ½ç›‘æ§
  monitorPerformance() {
    // CPUã€å†…å­˜ã€æ•°æ®åº“è¿æ¥æ•°ç›‘æ§
  }

  // ä¸šåŠ¡ç›‘æ§
  monitorBusiness() {
    // å¼€å¥–æˆåŠŸç‡ã€æŠ•æ³¨é‡ã€ä¸­å¥–ç‡ç›‘æ§
  }

  // å¼‚å¸¸ç›‘æ§
  monitorErrors() {
    // é”™è¯¯æ—¥å¿—ã€å¼‚å¸¸å‘Šè­¦
  }
}

// æ—¥å¿—é…ç½®
const loggerConfig = {
  level: 'info',
  format: 'json',
  transports: [
    new winston.transports.File({ filename: 'logs/error.log', level: 'error' }),
    new winston.transports.File({ filename: 'logs/combined.log' }),
    new winston.transports.Console()
  ]
};
```

## ğŸ”’ å®‰å…¨æªæ–½

### 1. æ•°æ®å®‰å…¨

```typescript
// å¼€å¥–å·ç åŠ å¯†å­˜å‚¨
class SecurityManager {
  // å·ç ç”Ÿæˆæ—¶åŠ å¯†
  encryptNumbers(numbers: number[]): string {
    const key = process.env.ENCRYPTION_KEY;
    return crypto.encrypt(JSON.stringify(numbers), key);
  }

  // å¼€å¥–æ—¶è§£å¯†éªŒè¯
  decryptNumbers(encrypted: string): number[] {
    const key = process.env.ENCRYPTION_KEY;
    const decrypted = crypto.decrypt(encrypted, key);
    return JSON.parse(decrypted);
  }

  // æŠ•æ³¨æ•°æ®å®Œæ•´æ€§æ ¡éªŒ
  validateBetData(betData: any): boolean {
    // æ ¡éªŒæŠ•æ³¨é‡‘é¢ã€èµ”ç‡ã€æ—¶é—´ç­‰
    return true;
  }
}
```

### 2. é˜²åˆ·æœºåˆ¶

```typescript
// é˜²åˆ·é™åˆ¶
class AntiSpamManager {
  // æŠ•æ³¨é¢‘ç‡é™åˆ¶
  checkBetFrequency(userId: string): boolean {
    // æ¯åˆ†é’Ÿæœ€å¤šæŠ•æ³¨10æ¬¡
    return true;
  }

  // IPé™åˆ¶
  checkIPLimit(ip: string): boolean {
    // æ¯IPæ¯åˆ†é’Ÿæœ€å¤š100æ¬¡è¯·æ±‚
    return true;
  }

  // å¼‚å¸¸æ£€æµ‹
  detectAbnormalBehavior(userId: string): boolean {
    // æ£€æµ‹å¼‚å¸¸æŠ•æ³¨æ¨¡å¼
    return false;
  }
}
```

è¿™ä¸ªå®Œæ•´çš„è®¾è®¡æ–¹æ¡ˆæ¶µç›–äº†åˆ†åˆ†æ—¶æ—¶å½©ç³»ç»Ÿçš„æ‰€æœ‰æ ¸å¿ƒåŠŸèƒ½ï¼Œå®Œå…¨åŸºäºæ‚¨çš„ç©æ³•æ–‡æ¡£ï¼Œç¡®ä¿æ¯ä¸ªç»†èŠ‚éƒ½å¾—åˆ°æ­£ç¡®å®ç°ã€‚ç³»ç»Ÿå…·å¤‡é«˜å¯ç”¨æ€§ã€é«˜æ€§èƒ½å’Œé«˜å®‰å…¨æ€§çš„ç‰¹ç‚¹ã€‚
